Title:  Writeup for Project 1, Spring 2010

 Date:  04/12/2010

 Group Num 03 :        Name            USC Email        Student ID

                       Alex Lee        alexl            6922218502
                       Kris Tai        ktai             6353657107
		       Tim Zimmer      tzimmer 		4814912664

*********************************************
**Project 3 Test Documentation see part V.**
*********************************************

I. Requirements:

	For this project, we have 3 different, distinct requirements.
		
		I. Implementation of the TLB (Translation Lookaside Buffer)
			+ The TLB resides in the machine directory, and is already initialized by existing machine code
			+ The TLB's function is to act as a fast cache that provides a direct pipeline from the CPU to main Memory
			+ There must be software management for the TLB, which will be used on TLB misses. 
			+ Dirty bits must be taken care of in the algorithm, ensuring that TLB state is set correctly			
			+ User Programs must run to completion

		II. Implementaion of Virtual Memory (Swap Files w/ FIFO and RAND, Inverted Page Table, and TLB):
			+ Virtual Memory gives user programs the illusion of large contiguous chunks of memory
			+ Virtual Memory is constructed via Swap Files, and IPT, and a TLB
			+ The IPT, or Inverted Page Table, is an operating system data structure that maps physical addresses into main Memory
			+ There is only one IPT in the entire instance of Nachos
			+ The IPT is invisible to the system
			+ The Swap File is a file that resides on disk, which contains data for evicted pages
			+ The Swap File is read from and also written to, using existing Kernel calls.
			+ 2 Page Replacement Algorithms, FIFO and Random, must be implemented to evict pages
			+ 2 or more user programs LARGER than memory must run to completion
			+ Also, memory is no longer pre-loaded. 

		III. Implementation of Remote Procedural Calls 
			+ Basic networking is set up in Nachos. 
			+ Nachos makes use of existing classes, like postOffice, to relay messages between servers and clients
			+ Lock and CV elements need to be rewritten to conform to the new networking protocols
         
	
II. Assumptions:
	+ Matmult is the user program that is used in testing
	+ It is impossible to test Part 1 of this Project, since Part 1 is the groundwork for Part 2. In order to test Part 1 solely, Part 2 can not exist.
		+ Based on what we know above, the success of the test for Part 2 is deemed sufficient evidence for the feasibility of Part 1. 
	+ 

III. Design:
	
	// Design for Parts 1 and 2
	// General Description of the Algorithm
	A. Get the virtual page required.
   		1. Ensure that the page is within a legal range.
	B. Check to see whether the needed page is in the IPT.
		1. Iterate through the IPT, and match the process id of the IPT to that of the current thread's address space.
			a. If they are the same, then proceed to 2.
			b. If iterated through the entire array, then this is a miss. Go to step C.  
		2. Check to see if the virtual page in the IPT is the same as the virtual page obtained in step A.
			a. If so, then we have an IPT hit. 
			b. Update the TLB 
	C. This is an IPT miss.
		1. Find a place in main memory that is open. 
			a. If it is full, go to step 2.
			b. If not, go to step 6b. 
		2. Using FIFO / Rand, select a page to evict
		3. Set the valid bits in the TLB to false
		4. Save the page if it is dirty, to a swap file
		5. Evict the page, by shifting the FIFO array
		6. Check to see if the new page is inside the swap file
			a. If it is, read it.
			b. If not, then simply load the page into main memory
		7. Update the Inverted Page Table
		8. Update the TLB
	D. Increment the TLB Counter
	D. Restart the User Instruction, without incrementing the PC Register

	// Design for Part 3
	A. A server runs continuously waiting for client requests sent over the network.
	B. Clients send lock and CV requests to the server (create lock, acquire, release, create CV, wait, signal, broadcast).
	C. Server tracks all locks and CVs requested by the clients.
	D. Clients wait until a response is received from the server after certain requests (acquire and wait) before continuing.
   		
		
IV. Implementation:

            + Files Modified:
			exception.cc
			system.h - externs/structs
			addrspace.h/.cc
			progtest.h/.cc
			exectest.c
			matmult.c
			system.cc
			system.h
			Makefile.common
			network/Makefile
			            
	    + Files added
			NewTranslationEntry.h
			Project3Server.cc
			ServerLock.h/.cc
			ServerCond.h/.cc
			
            + Data Structures added, and the file they were added to.
		the following to system.cc / h
			ipt
			fifoCounter
			fifo
			tlbCounter
		the following to Project3Server.cc
			serverLockTable
			serverCondTable
			
			
            + Data Structures modified, and the file they were added to.
			N/A
			
            + Functions added and in which file.
			N/A	

            + Functions modified and in which file.
		the following to exception.cc
						
			
			
V. Testing:  (For each test case, you must show)

            + How to test
			
			-in the code/vm/ directory, type the following to execute tests

				"run" - a shell script that calls exectest which tests 2 instances of the user program matmult	

			-in the code/network/ directory, do the following (in order) to execute a test.
				
				In one terminal: nachos -m 0 -server  --> this starts the server on machine 0.
				In another terminal: nachos -m 1 -x ../test/lockTest1 --> this tests locks and CVs.
				In another terminal: nachos -m 2 -x ../test/lockTest2 --> this completes the above test.
				

            + Test Output

			ExecTest:
				Aside from the printing of the default virtual address information, it should print out the final
				value of 7220. 
			*Important note: Exectest runs two instances of matmult (each 50+ pages > Memory), however only the final print
			statement for the second matmult will print out. This is because the first one prints out earlier, but it is
			impossible to see given the fact that the virtual addresses are constantly being printed out (the output will
			get lost amongst the print of VAs). The one way we know that is running is by looking at the amount of ticks.
			Each matmult runs about 50,000+ ticks, so a combined number of ticks > 100,000 means that both matmults have run,
			and that they have run to completion.

			lockTest1:
				This test will create two locks (lock0 and lock1) and one CV (cv0).
				It will then acquire lock0 and lock1.
				Then, it will send a Wait request with cv0 and lock0.  At this point, the program should be waiting.
				After Waiting, this test will release lock0 and lock1.

			lockTest2:
				This test will acquire lock0, which should be released when lockTest1 sent the Wait request.
				This test will then send a Signal request with cv0 and lock0.  
				Then it will release lock0.  This should wake up lockTest1.
				Then it will acquire lock1.  Lock1 will be available once lockTest1 wakes up and releases it.
				Then it will release lock1.


VI. Discussion:

            + Experiment expectation.  (What you hope will happen.)
			
			Exectest:
			The test should output 7220, which is the final result after the extensive multiplication / addition of the 
			two matrices. As mentioned before, however, there will only be one output, since the other userprogram will output
			its value before, when the system is still outputing virtual addresses. It will be impossible to notice this since 
			the console prints out the value at such rapidity.

			lockTest1/2:
			This set of tests should show that lock/CV requests are passed between the clients and the server.  It should also show that locks and CVs can be shared between multiple clients.


            + Experiment result.  (What actually happens.)
		
			Exectest:
			Correct output.
			
			lockTest1/2:
			Correct output.


            + Explanation

                    	The page fault exception is handled correctly, through the use of a swap file, tlb, and ipt. 

			
VII. Miscellaneous:

- Whatever else you want the grader know about your development.  You can create your own subsections headings here.
	    
	    + Assumptions	

	
